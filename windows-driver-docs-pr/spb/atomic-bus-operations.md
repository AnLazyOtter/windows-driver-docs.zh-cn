---
title: 原子总线操作
description: 若要使用的与存储连接的外围设备的某些硬件功能，存储控制器 （即外围设备驱动程序） 的客户端可能需要执行一系列数据传输到和从设备作为一个原子总线操作。
ms.assetid: F8CD670F-C817-40BF-AF4B-5F3839E46EFB
ms.date: 04/20/2017
ms.localizationpriority: medium
ms.openlocfilehash: 9ae9bd621f34e3a96f48de5f81ee7aed82cbcbb4
ms.sourcegitcommit: fb7d95c7a5d47860918cd3602efdd33b69dcf2da
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 06/25/2019
ms.locfileid: "67369589"
---
# <a name="atomic-bus-operations"></a>原子总线操作


若要使用的与存储连接的外围设备的某些硬件功能，存储控制器 （即外围设备驱动程序） 的客户端可能需要执行一系列数据传输到和从设备作为一个原子总线操作。 因为在总线上没有其他客户端传输到或从设备的数据序列完成之前，传输序列是原子的。

客户端来执行传输序列，如总线原子操作是将发送的常见方式[ **IOCTL\_存储\_EXECUTE\_序列**](https://msdn.microsoft.com/library/windows/hardware/hh450857)请求到目标设备。 在此请求中，客户端指定的序列，如一系列简单的读取和写入传输。 列表可以是字符串的任意长度。 在其中列出，并每次读取或写入可以传输任意数目的字节顺序进行读写。 大多数存储控制器支持**IOCTL\_存储\_EXECUTE\_序列**请求。

## <a name="spb-controller-locks"></a>存储控制器锁


执行原子传输序列的不太常见方法是使用的存储控制器锁。 客户端发送[ **IOCTL\_存储\_锁\_控制器**](https://msdn.microsoft.com/library/windows/hardware/hh450858)请求获取锁，并且[ **IOCTL\_存储\_解锁\_控制器**](https://msdn.microsoft.com/library/windows/hardware/hh450859)释放锁的请求。 控制器锁、 简单的读取和写入的任何序列，当保留客户端 ([**IRP\_MJ\_读取**](https://docs.microsoft.com/windows-hardware/drivers/kernel/irp-mj-read)并[ **IRP\_MJ\_编写**](https://docs.microsoft.com/windows-hardware/drivers/kernel/irp-mj-write)) 客户端向设备发送的请求执行作为一个原子操作总线上。

大多数存储连接的外围设备不需要控制器锁，并且大多数存储控制器驱动程序不实现对这些锁的支持。 但是，一些客户端可能需要使用控制器锁来访问具有特殊功能的设备。

例如，设备可能会实现可以仅通过原子总线上的读取-修改-写入操作访问的设备功能。 若要执行此类操作，客户端发送下列四个 I/O 请求 （按所示的顺序）：

1.  **IOCTL\_存储\_锁\_控制器**– 获取控制器锁。
2.  **IRP\_MJ\_读取**– 从目标设备中读取的数据块。
3.  **IRP\_MJ\_编写**– 将修改后的数据写回到设备。
4.  **IOCTL\_存储\_解锁\_控制器**– 释放控制器锁。

上面的列表中读取操作，完成后客户端将从设备读取和修改数据之前将其写回到设备的数据进行解释。

但是，一些连接存储的设备具有需要控制器锁的功能。 对于大多数设备都需要原子总线操作， [ **IOCTL\_存储\_EXECUTE\_序列**](https://msdn.microsoft.com/library/windows/hardware/hh450857)请求已足够。

不要混淆与存储连接锁的存储控制器锁。 在这两个客户端共享相同的存储连接的外围设备的访问权限的非典型情况下，客户端可以使用连接锁暂时获取独占访问设备。 有关详细信息，请参阅[存储连接锁定](https://docs.microsoft.com/windows-hardware/drivers/spb/spb-connection-locks)。

## <a name="hardware-bus-signals"></a>硬件总线信号


若要处理[ **IOCTL\_存储\_EXECUTE\_序列**](https://msdn.microsoft.com/library/windows/hardware/hh450857)请求，存储控制器驱动程序配置以生成适当的控制器硬件在传输序列期间总线上的信号。 外围设备连接到总线可能依赖于这些信号来检测原子总线操作时。 向发出信号的一套硬件，用于执行传输序列，因为原子总线操作上的总线类型取决于存储控制器。

对于 I²C 总线，控制器首先序列传输汽车上，启动位，并通过传输停止位结束序列。 之间的启动和停止位，作为单一的原子总线操作执行数据传输到和从设备的序列。 除了序列中最后一个传输，每次传输后跟 I²C 重新启动操作 （通过停止位前面没有重复的启动位）。

对于 SPI 总线，控制器首先序列添加到目标设备的芯片选择行，并通过 deasserting 芯片选择行结束序列。 通过保留持续的数据传输序列期间添加总线芯片选择行，传输作为单个、 原子总线操作执行。

## <a name="an-example-ic-device"></a>示例 I²C 设备


典型的外围设备 I²C 总线上可能会实现多个内部设备函数。 若要访问其中的一些功能，客户端可能会使用[ **IOCTL\_存储\_EXECUTE\_序列**](https://msdn.microsoft.com/library/windows/hardware/hh450857)请求。

例如，I²C 外围设备可能包含以下两个内部寄存器：

-   一个*函数地址注册*向客户端写入设备函数来访问的内部地址。
-   一个*数据寄存器*通过该客户端读取数据或将数据写入到指定的函数地址。

在此示例中 I²C 外围设备将解释写入后启动位，为函数地址，将加载到函数地址注册到设备的第一个字节。 任何额外的字节传输到或从设备传输之前序列结束 （如下所述的停止位） 被视为由设备将数据传输通过数据寄存器。

若要执行写操作，客户端发送执行写入操作 ([**IRP\_MJ\_编写**](https://docs.microsoft.com/windows-hardware/drivers/kernel/irp-mj-write)) 在其中写入缓冲区中的第一个字节是函数地址，剩余的请求缓冲区中的字节将数据写入到的函数地址。

从设备读取得更复杂。 假设在此示例支持一种"快速读取"功能，会自动重置函数地址注册到其默认值为 0，当一个停止位 I²C 设备检测到总线上。 使用此功能，客户端可以从函数地址 0 读取数据，而不必首先写入函数地址注册。 此功能可以提高读取操作，尤其是当大多数读取来自函数地址 0 和都相对较短的设备的速度。

但是，若要从非零值的函数地址中读取的数据块，客户端仍必须编写一个字节函数地址注册到的数据寄存器中读取数据块之前。 客户端必须执行这些写入和读取作为一个原子总线操作，以防止总线控制器传输停止位函数地址写入注册后，并从数据寄存器中读取的之前的传输。 否则，停止位将导致从函数地址 0 而不是从非零值的函数地址中读取数据。

以下列表描述了客户端将发送到 I²C 设备在此示例中执行位于非零值的函数地址的设备中的数据的读取-修改-写入操作的 I/O 请求的一系列：

1.  **IOCTL\_存储\_EXECUTE\_序列**-执行一个 I/O 传输序列，从设备读取数据。 此序列中的第一个传输是字节写入函数地址注册。 第二个序列中的传输是读取一些字节从所选的函数的地址。 这些两个传输总线上以原子方式执行。
2.  **IRP\_MJ\_编写**-将数据写入到设备。 此请求写入缓冲区中的第一个字节写入到的函数地址寄存器的值。 缓冲区中剩余的字节是数据要写入到所选的函数地址。

可能会改为使用的请求的其他模式，才能执行此读取-修改-写入操作。 例如， **IRP\_MJ\_编写**可以替换为在步骤 2 中的请求**IOCTL\_存储\_EXECUTE\_序列**请求它指定两个数据传输，这两个写操作。 序列中的首次传输将一个字节加载到函数地址注册。 第二个传输将数据字节写入到所选的函数地址。 此请求，但不同于**IRP\_MJ\_编写**请求在步骤 2 中，不需要客户端以便合并的函数地址字节和相同的写入缓冲区中的数据字节。

若要在此设备中的函数地址 0 上执行读取-修改-写入**IOCTL\_存储\_EXECUTE\_序列**简单的读取可替换为前面的列表的步骤 1 中的请求 ([ **IRP\_MJ\_读取**](https://docs.microsoft.com/windows-hardware/drivers/kernel/irp-mj-read)) 请求。

 

 




