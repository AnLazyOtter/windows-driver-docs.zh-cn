---
title: 支持内存库中的帧缓冲区
description: 支持内存库中的帧缓冲区
ms.assetid: edb0421b-fd1d-43da-9c1f-3414182282fb
keywords:
- 显示驱动程序 WDK Windows 2000，存款的帧缓冲区
- 存款的帧缓冲区 WDK Windows 2000 显示
- 显示帧缓冲区 WDK Windows 2000
- 存款的内存 WDK Windows 2000 时，显示
- 存款的回调 WDK Windows 2000 显示
- 银行 WDK Windows 2000 显示
- 映射到存款的帧缓冲区的视频内存
- 跨越多个银行
- 帧缓冲区 WDK Windows 2000 中的多个银行显示
ms.date: 04/20/2017
ms.localizationpriority: medium
ms.openlocfilehash: c736ca73d6764e574de3269cc8c0ce57b994481f
ms.sourcegitcommit: fb7d95c7a5d47860918cd3602efdd33b69dcf2da
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 06/25/2019
ms.locfileid: "67374389"
---
# <a name="supporting-banked-frame-buffers"></a>支持内存库中的帧缓冲区


## <span id="ddk_supporting_banked_frame_buffers_gg"></span><span id="DDK_SUPPORTING_BANKED_FRAME_BUFFERS_GG"></span>


大部分今天的加速器*帧缓冲区*，以线性方式可以映射到 CPU 地址空间。 此类设备的显示驱动程序不需要支持存款的帧缓冲区。

不能直接访问 GDI*累积的积分内存*存款的帧缓冲区与相关联。 因此，具有此类的帧缓冲区的设备的显示器驱动程序必须将帧缓冲区划分为一系列连续银行，并提供执行相应帧缓冲区银行为其绘制操作的 GDI 一种方法。 也就是说，GDI 进行移动到后续银行，必要时，若要通过一种机制，称为完成与绘制操作之前将数据写入到的帧缓冲区的一个银行*累积的积分回调*。

*Permedia*示例显示器驱动程序附带的驱动程序开发工具包 (DDK) 提供的实现存款的帧缓冲区支持的示例代码。

**请注意**   Microsoft Windows Driver Kit (WDK) 不包含 3Dlabs Permedia2 (*3dlabs.htm*) 和 3Dlabs Permedia3 (*Perm3.htm*) 示例显示器驱动程序。 可以从 Windows Server 2003 SP1 DDK，可以从 DDK-WDHC 网站的 Windows 驱动程序开发工具包页面下载来获取这些示例驱动程序。

 

下图显示了示例加速器的帧缓冲区 1024年 × 768 VGA 显示缓冲区，划分为多个银行。 此图仅用于演示目的提供。 显示驱动程序却不专门使用的物理地址 A000，但使用传递给它的微型端口驱动程序的逻辑地址。

![说明映射到存款的帧缓冲区的视频内存关系图](images/banking1.png)

在此示例中，视频内存内容被写入加速器通过一系列地址连续银行的帧缓冲区的绘制操作。 就而言 GDI，其描述的操作的每个显示为标准的帧缓冲区而不属于不同银行的加速器的帧缓冲区。 快捷键的设备驱动程序处理会导致 GDI 银行的银行基础上绘制到加速器的帧缓冲区的银行操作。

帧缓冲区*设备管理面*时加速器采用存款的帧缓冲区中，以便显示驱动程序挂钩绘图函数调用。 显示驱动程序挂钩的调用，如绘制路径、 填充路径时或*位块传输*，它会确定哪些银行公会帧缓冲区受调用绘图函数。

如果驱动程序选择具有 GDI 执行绘图函数，该驱动程序会调用相应 **Eng * * * Xxx*函数。 但是，在调用前，显示器驱动程序，必须修改已挂钩调用中收到的剪辑和图面对象和回调中的这些已修改的对象传递给 GDI。 若要防止超出银行的盘区的绘图的 GDI 将会修改剪辑和图面对象。 也就是说，如果 GDI 调用以绘制的现有路径部分中下一个组，并且无需修改的剪辑和图面对象，GDI 将写入到当前银行的盘区以外的内存。 如果尝试银行的盘区之外绘制 GDI，所产生的访问冲突可能很难跟踪。

示例存款的帧缓冲区中下图显示了在显示屏上绘制一个椭圆对象如何跨越两个银行的存款的帧缓冲区，银行\_1 和银行\_2。

![说明跨越多个银行公会帧缓冲区的绘制的对象的关系图](images/pvscan0.png)

若要绘制此对象，GDI 必须首先绘制椭圆的上半部分 (BANK 中\_1) 到标准帧缓冲区，并到相同的标准缓冲区然后绘制椭圆的下半部分。 显示驱动程序必须然后将这些两个连续写入的 GDI 映射到银行\_1 和银行\_存款的帧缓冲区以显示，并还防止 GDI 写入超出限制的组，每组 2。

在执行存款的帧缓冲时，显示器驱动程序，可以通过检查调用的参数或通过回调 GDI 确定对象 （目标矩形的大小） 的边界。 从对象的边界，该驱动程序可以确定多少组跨越的对象。 每个边界矩形上并接触的银行，显示驱动程序调用返回到相应的 GDI 绘制函数，更改每个调用的值。

驱动程序更改[ **CLIPOBJ** ](https://docs.microsoft.com/windows/desktop/api/winddi/ns-winddi-_clipobj)成员最初传递的 GDI 对应于银行的边界中的更改。 以便 GDI 不会尝试绘制到银行的界限之外，将重新定义的顶部和底部的扫描值。 银行管理器采用从 GDI 中获取原始 CLIPOBJ 数据，并保留的值，用于更高版本还原。 然后它会更改要提供新的边界**rclBounds.top**并**rclBounds.bottom**值，用于描述要绘制到银行的程度。 在银行，GDI 必须执行剪辑到的大小，可防止绘制的完整路径和覆盖当前银行的限制。

如果通过 GDI 传递原始 CLIPOBJ 被定义为**NULL**或 DC\_TRIVIAL，然后显示驱动程序将传递替代 CLIPOBJ，通过创建**EngCreateClip**以便 GDI 将剪辑到单个银行的扩展盘区。 显示驱动程序如果 CLIPOBJ 复杂，例如在上图中所示的椭圆上的三角形状剪辑对象，修改具有复杂 CLIPOBJ **rclBounds.top**和**rclBounds.bottom**值来生成两个剪辑对象之间的累加性效果。 因此，GDI 被阻止编写的银行末尾。 该驱动程序还必须还原以前从 GDI 中获取的 CLIPOBJ 数据的原始边界。

除了更改边界值，显示驱动程序设置 OC\_银行\_中的剪辑标志 **剪辑对象 * * *。*

此外必须进行 GDI 绘制引用标准帧缓冲区的开头。 当调用以绘制，GDI 只需获取一个指针指向 SURFOBJ，其中包括**pvScan0**， **lDelta**，并**iBitmapFormat**成员。 GDI 计算，如下所示使用这些值绘制图面上的位置：

```cpp
start_draw_point = pvScan0 + (y*lDelta) + (x*PixelSize(iBitmapFormat))
```

其中*x*和*y*是的坐标绘制即将开始，并*启动\_绘制\_点*是在该地址的第一个地址将绘制像素。 GDI 上每个绘图调用中执行此计算，并始终引用为 SURFOBJ **pvScan0**，这是标准的帧缓冲区开头的逻辑地址。

例如，如果 GDI 需要绘制的 8 位每像素的 64k 帧缓冲区的全部内容，开始的逻辑地址**pvScan0** = 0x100000，它将结束 0x10FFFF 的绘图操作 (0x100000 + (63\*1024年) + (1023年)），其中*y*是 63 **lDelta**为 1024，并*x*为 1023 （最后一个扫描行中最后一个像素的位置）。

下一次显示驱动程序调用 GDI 绘制该对象的一部分内*下一步*银行存款的帧缓冲区，GDI 将的值解释*y*为 64。 值为 0x100000 **pvScan0** 64 *y*，GDI 将尝试开始编写 0x110000 上的数据。 但是，0x110000 超出 64k 帧缓冲区的 0x10FFFF 范围，并且必须未写入到通过 GDI 在执行此操作。

因此，当显示驱动程序请求时将出现在第二个和后续银行的帧缓冲区中将数据写入的 GDI，驱动程序必须递减的值**pvScan0**以便 GDI 计算，它是起始点仍在引用的 0x100000 示例地址。 继续在示例中，这意味着递减的值**pvScan0**为 0x090000 绘制到第二个插槽中的帧缓冲区时的值。 由于此更改对**pvScan0**，GDI 仍然绘制到地址 0x100000 的引用。 也就是说，0x090000 + (64\*1024年) + 0 是等于 0x100000，GDI 必须以使数据能够映射到第二个插槽中的帧缓冲区中绘制。

 

 





