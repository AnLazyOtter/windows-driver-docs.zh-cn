---
title: 始终可抢占且始终可中断
description: 始终可抢占且始终可中断
ms.assetid: 3da667b4-50f3-4536-9049-65719fa003ce
keywords:
- preemptible 设计 WDK 内核
- 可中断设计 WDK 内核
- 中断请求级别 WDK 内核
- IRQL 级别 WDK 内核
- 变量优先级特性 WDK 内核
- 优先化条件 WDK 内核
- 硬件优先级 WDK 内核
- 更高版本的 IRQL 级别 WDK 内核
- 较低的 IRQL 级别 WDK 内核
- PASSIVE_LEVEL WDK
- APC_LEVEL WDK
- DISPATCH_LEVEL WDK
- WAKE_LEVEL WDK
- 延迟的过程调用 WDK 内核
- Dpc WDK 内核
- 任意线程上下文 WDK 内核
- 线程抢占 WDK 内核
- 线程优先级 WDK 内核
ms.date: 06/16/2017
ms.localizationpriority: medium
ms.openlocfilehash: a513660a95cac611b1258e1ab4a898eb9a135c45
ms.sourcegitcommit: 0cc5051945559a242d941a6f2799d161d8eba2a7
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/23/2019
ms.locfileid: "63326055"
---
# <a name="always-preemptible-and-always-interruptible"></a>始终可抢占且始终可中断





Preemptible、 可中断设计的操作系统的目标是使系统性能最大化。 任何线程可以通过具有较高的优先级的线程会被抢占，并可以被更高的级别中断请求 (IRQL) 运行的例程中断任何驱动程序中断服务例程 (ISR)。

内核组件确定代码序列的运行时，根据这些优先级条件之一：

-   线程内核定义运行时优先级方案。

    在系统中的每个线程具有一个关联的优先级属性。 一般情况下，大多数线程都*变量*优先级属性： 它们是始终 preemptible，计划要运行轮循机制，目前在相同的优先级级别的所有其他线程。 某些线程都*实时*优先级属性： 这些严格要求时间的线程运行到完成，除非它们都优先于具有更高版本的实时优先级特性的线程。 Microsoft Windows 体系结构不提供本质上是实时系统。

    无论其优先级特性、 系统可以在任何线程会被抢占时的硬件中断和发生某些类型的软件中断。

-   内核定义*中断请求级别*(IRQL) 特定的中断向量在给定平台上分配给。

    内核设置优先级的硬件和软件中断，以便某些内核模式代码，包括大多数驱动程序，从而使它在系统中具有计划优先级要高于其他线程在更高版本于 Irql 运行。 由一段的内核模式驱动程序代码执行的特定 IRQL*硬件优先级*的其基础设备。

    内核模式代码始终是可中断： 中断具有较高的 IRQL 值出现在任何时候，从而导致其他内核模式代码段具有更高版本系统分配 IRQL 该处理器上立即运行。 但是，当在给定的 IRQL 运行时的一段代码，内核会屏蔽处理器上的 IRQL 值较小或相等的所有中断向量。

最低的 IRQL 级别称为被动\_级别。 在此级别，会屏蔽不中断向量。 线程通常运行在 IRQL = 被动\_级别。 下一步的更高版本的 IRQL 级别适用于软件中断。 这些级别包括 APC\_级别、 调度\_级别，或对于内核调试，唤醒\_级别。 设备中断具有仍然较高的 IRQL 值。 内核保留系统关键的中断，如从系统时钟或总线错误的最高的 IRQL 值。

某些系统支持例程运行在 IRQL = 被动\_级别，因为它们并实现为可分页代码或访问可分页数据，或某些内核模式组件设置了其自己的线程。

同样，某些[标准驱动程序例程](https://docs.microsoft.com/windows-hardware/drivers/kernel/introduction-to-standard-driver-routines)通常运行在 IRQL = 被动\_级别。 但是，多个标准驱动程序例程运行在 IRQL = 调度\_级别或，最低级别的驱动程序，在设备的 IRQL (也称为*DIRQL*)。 有关于 Irql 详细信息，请参阅[管理硬件优先级](managing-hardware-priorities.md)。

驱动程序中的每个例程是不间断。 这包括在被动比更高版本 IRQL 运行的任何例程\_级别。 在特定的 IRQL 运行的任何例程的更高版本的 IRQL 不中断发生时运行该例程时才保留的处理器的控件。

不同于某些较旧的个人计算机操作系统中的驱动程序，Microsoft Windows 驱动程序的 ISR 永远不会是大型、 复杂的例程，大部分驱动程序的 I/O 处理。 这是因为任何驱动程序*中断服务例程*(ISR) 可以中断 （例如，通过另一个驱动程序的 ISR) 在更高版本的 IRQL 运行的另一个例程。 因此，驱动程序的 ISR 不一定是保留的 CPU、 不间断地从开始到结束其执行路径中的控件。

在 Windows 驱动程序 ISR 通常保存硬件状态信息，队列*延迟过程调用*(DPC)，然后快速退出。 更高版本，系统取消排队驱动程序的 DPC，以便该驱动程序可以完成 I/O 操作在较低的 IRQL (调度\_级别)。 为了提高总体系统性能，在高于 Irql 运行的所有例程必须快速都放弃对 CPU 的控制。

在 Windows 中，所有线程都都可以线程上下文。 此上下文包括标识拥有线程，以及其他特征，如线程的访问权限的进程的信息。

一般情况下，最高级别的驱动程序正在请求驱动程序的当前的 I/O 操作的线程的上下文中调用。 中间级或最低级别的驱动程序可以永远不会假定它正在请求其当前的 I/O 操作的线程的上下文中执行。

因此，驱动程序例程通常在中执行*任意线程上下文*— 任何线程是最新的标准驱动程序例程调用时的上下文。 出于性能原因 （以避免上下文切换），非常少的驱动程序设置了其自己的线程。

 

 




